#需要额外组件的教程
EasyPy有支持扩充板来增加功能的实现. 主要控冲板提供下列功能

> * 1. 控制直流马达
> * 2. 控制业余爱好伺服电机
> * 3. 音乐播放及录音
> * 4. LCD显示
> * 5. OID


##1. 控制爱好伺服电机
EasyPy上有4个专用连接点，用于连接业余爱好伺服电机。这些电机有3根电线：接地，电源和信号。在EasyPy上，您可以在右下角连接它们，信号引脚位于最右侧。引脚X1，X2，X3和X4是4个专用伺服信号引脚。

![](https://raw.githubusercontent.com/Honor-D/EasyPython/master/img/wps33.png) 
 
在这张图片中，有一对公 - 双双适配器，用于将伺服系统连接到EasyPy上的插头引脚。

服务器上的接地线通常是最黑的，黑色或深棕色。电源线很可能是红色的。

伺服电源的引脚（标记为VIN）直接连接到EasyPy的输入电源。通过USB供电时，VIN通过5V USB电源线通过二极管供电。连接到USB，EasyPy可以为至少4个中小型伺服电机供电。

如果使用电池给EasyPy供电并运行伺服电机，请确保它不大于6V，因为这是大多数伺服电机可以承受的最大电压。（有些电机最高只需4.8V，因此请检查您使用的是哪种类型。）

###1.1. 创建伺服对象
将伺服插入位置1（带引脚X1的伺服）并使用以下命令创建伺服对象：

    >>> servo1 = pyb.Servo(1)

要改变伺服角度，请使用以下`angle`方法：

    >>> servo1.angle(45)
    >>> servo1.angle(-60)

这里的角度以度为单位，范围从约-90到+90，具体取决于电机。angle不带参数调用将返回当前角度：

    >>> servo1.angle()
    -60

请注意，对于某些角度，由于设置脉冲宽度时的舍入误差，返回的角度与您设置的角度不完全相同。

您可以将第二个参数传递给`angle`方法，该方法指定达到所需角度所需的时间（以毫秒为单位）。例如，要从当前位置到50度需要1秒（1000毫秒），请使用

    >>> servo1.angle(50, 1000)

该命令将立即返回，伺服将继续移动到所需的角度，并在它到达时停止。您可以将此功能用作速度控制，或同步2个或更多伺服电机。如果我们有另一台伺服电机（）那么我们就可以做到`servo2 = pyb.Servo(2)`

    >>> servo1.angle(-45, 2000); servo2.angle(60, 2000)

这会将伺服系统移动到一起，使它们都需要2秒才能达到最终角度。

> 注意：
使用上面两个表达式之间的分号，以便在REPL提示符下按Enter键时，它们会一个接一个地执行。在脚本中，您不需要这样做，您可以将它们一行写入另一行。

###1.2. 连续旋转伺服
到目前为止，我们一直在使用移动到特定角度并保持该角度的标准伺服系统。这些伺服电机可用于创建机器人的关节，或平移机构等。在内部，电动机具有可变电阻器（电位计），该电阻器测量电流角度并向电动机供电，与所需角度的距离成比例。所需的角度由伺服信号在线的高脉冲宽度设定。1500微秒的脉冲宽度对应于中心位置（0度）。脉冲以50Hz发送，即每秒50个脉冲。

您还可以获得连续顺时针或逆时针旋转的连续旋转伺服电机。旋转的方向和速度由信号在线的脉冲宽度设定。脉冲宽度为1500微秒对应于停止的电动机。小于或大于此的脉冲宽度意味着以给定的速度以一种方式或另一种方式旋转。

在EasyPy上，连续旋转电机的伺服对象与以前相同。事实上，使用`angle`你可以设置速度。但为了更容易理解预期内容，还有另一种方法`speed`可以设置速度：

    >>> servo1.speed(30)

`speed`具有与以下功能相同的功能`angle`：您可以获得速度，设置速度，并将其设置为达到最终速度的时间。

    >>> servo1.speed()
    30
    >>> servo1.speed(-20)
    >>> servo1.speed(0, 2000)

上面的最后一个命令会将电机设置为停止，但需要2秒钟才能完成。这基本上是对连续伺服加速度的控制。

伺服速度为100（或-100）被认为是最大速度，但实际上你可以比这更快，具体取决于特定的电机。

`angle`和`speed`方法（除了名称）之间的唯一区别是输入数字（角度或速度）转换为脉冲宽度的方式。

###1.3. 校准
从角度或速度到脉冲宽度的转换由伺服对象使用其校准值完成。要获得当前校准，请使用

    >>> servo1.calibration()
    (640, 2420, 1500, 2470, 2200)

这里有5个数字，它们有意义：

1. 最小脉冲宽度; 伺服接受的最小脉冲宽度。

2. 最大脉冲宽度; 伺服接受的最大脉冲宽度。

3. 中心脉冲宽度; 将伺服置于0度或0速度的脉冲宽度。

4. 脉冲宽度对应90度。这设置了`angle`角度与脉冲宽度方法的转换。

5. 脉冲宽度对应于速度100.这设定了`speed`速度到脉冲宽度的方法的转换。

您可以使用以下命令重新校准伺服（更改其默认值）：

    >>> servo1.calibration(700, 2400, 1510, 2500, 2000)

当然，您可以更改上述值以适合您的特定伺服电机。

##2. LED渐灭渐亮
除了打开和关闭LED之外，还可以使用脉冲宽度调制（PWM）来控制LED的亮度，脉冲宽度调制是一种从数字引脚获得可变输出的常用技术。这使我们可以淡化LED：

![](https://raw.githubusercontent.com/Honor-D/EasyPython/master/img/wps34.png) 

###2.1. 组件
你会需要：

 - 标准5或3 mm LED
 - 100奥姆电阻器
 - 电线
 - 面包板（可选，但更容易）

###2.2. 连接起来
在本教程中，我们将使用该`X1`引脚。将电阻器`X1`的一端连接到LED 的另一端，将另一端连接到LED 的阳极，即长腿。将LED 的阴极连接到地。

![](https://raw.githubusercontent.com/Honor-D/EasyPython/master/img/wps35.jpg) 

###2.3. 代码
通过检查EasyPy的快速参考，我们看到它`X1`连接到定时器5（）的通道1 。因此，我们将首先为定时器5创建一个对象，然后为信道1 创建一个对象：`TIM5 CH1TimerTimerChannel`

    from pyb import Timer
    from time import sleep
    
    # timer 5 will be created with a frequency of 100 Hz
    tim = pyb.Timer(5, freq=100)
    tchannel = tim.channel(1, Timer.PWM, pin=pyb.Pin.board.X1, pulse_width=0)

通过控制脉冲宽度来控制PWM中LED的亮度，脉冲宽度即LED在每个周期上的时间量。定时器频率为100 Hz，每个周期需要0.01秒或10 ms。

为了达到本教程开头所示的衰落效果，我们希望将脉冲宽度设置为较小的值，然后慢慢增加脉冲宽度以使LED变亮，并在达到某个最大亮度时重新开始：

    # maximum and minimum pulse-width, which corresponds to maximum ;最大和最小脉冲宽度，对应于最大
    # and minimum brightness					; 和最小亮度
    max_width = 200000
    min_width = 20000
    
    # how much to change the pulse-width by each step		; 每步改变脉冲宽度
    wstep = 1500
    cur_width = min_width
    
    while True:
      tchannel.pulse_width(cur_width)
    
      # this determines how often we change the pulse-width. It is 
      # analogous to frames-per-second		;这决定了我们改变脉冲宽度的频率。这是类似于帧每秒
      sleep(0.01)
    
      cur_width += wstep
    
      if cur_width > max_width:
        cur_width = min_width

###2.4. 呼吸效果
如果我们想要有一个呼吸效果，LED从昏暗到亮，然后从亮到昏暗，那么我们只需要反转`wstep`当我们达到最大亮度时的符号，并以最小亮度再次反转。为此，我们将`while`循环修改为：

    while True:
      tchannel.pulse_width(cur_width)
    
      sleep(0.01)
    
      cur_width += wstep
    
      if cur_width > max_width:
        cur_width = max_width
        wstep *= -1
      elif cur_width < min_width:
        cur_width = min_width
        wstep *= -1

###2.5. 高级练习
您可能已经注意到LED亮度似乎缓慢消退，但增长很快。这是因为我们的眼睛以对数方式解释亮度（韦伯定律 ），而LED的亮度线性变化，每次都相同。你怎么解决这个问题？（提示：对数函数的反义词是什么？）

###2.6. 附录
我们也可以使用数模转换器（DAC）来实现相同的效果。PWM方法的优点是每次驱动LED具有相同的电流，但是时间长度不同。这允许更好地控制亮度，因为LED不一定表现出驱动电流和亮度之间的线性关系。

##3. LCD和触摸传感器皮肤
焊接和使用LCD和触摸传感器皮肤。

![](https://raw.githubusercontent.com/Honor-D/EasyPython/master/img/wps36.png)![](https://raw.githubusercontent.com/Honor-D/EasyPython/master/img/wps37.png)

以下视频显示瞭如何将接头焊接到LCD外壳上。在视频结束时，它将向您展示如何将LCD外观正确连接到EasyPy。

有关皮肤组件的电路原理图和数据表，请参阅EasyPy硬件。

###3.1. 使用
要开始使用LCD，请在MicroPython提示符下尝试以下操作。确保LCD外壳贴在EasyPy上，如本页顶部所示。

    >>> import pyb
    >>> lcd = pyb.LCD('X')
    >>> lcd.light(True)
    >>> lcd.write('Hello uPy!\n')

您可以使用以下代码制作简单的动画：

    import pyb
    lcd = pyb.LCD('X')
    lcd.light(True)
    for x in range(-80, 128):
        lcd.fill(0)
        lcd.text('Hello uPy!', x, 10, 1)
        lcd.show()
        pyb.delay(25)

###3.2. 使用触摸传感器
要读取触摸传感器数据，您需要使用I2C总线。MPR121电容式触摸传感器的地址为90。

要开始使用，请尝试：

    >>> import pyb
    >>> i2c = pyb.I2C(1, pyb.I2C.MASTER)
    >>> i2c.mem_write(4, 90, 0x5e)
    >>> touch = i2c.mem_read(1, 90, 0)[0]

上面的第一行产生一个I2C对象，第二行产生4个触摸传感器。第三行读取触摸状态，touch变量保持4个触摸按钮（A，B，X，Y）的状态。

有一个简单的司机在这里 ，它允许您设置的阈值和去抖参数，并轻松地阅读触摸状态和电极的电压水平。将此脚本复制到EasyPy（闪存或SD卡，在顶级目录或lib/目录中），然后尝试：

    >>> import pyb
    >>> import mpr121
    >>> m = mpr121.MPR121(pyb.I2C(1, pyb.I2C.MASTER))
    >>> for i in range(100):
    ...   print(m.touch_status())
    ...   pyb.delay(100)
    ...

这将连续打印出所有电极的触摸状态。尝试依次触摸每一个。

请注意，如果将LCD外壳置于Y位置，则需要使用以下命令初始化I2C总线：

    >>> m = mpr121.MPR121(pyb.I2C(2, pyb.I2C.MASTER))

还有一个演示，它将LCD和触摸传感器结合在一起，可以在这里找到。

##4. AMP音频皮肤
焊接和使用AMP音频皮肤。

![](https://raw.githubusercontent.com/Honor-D/EasyPython/master/img/wps38.png)![](https://raw.githubusercontent.com/Honor-D/EasyPython/master/img/wps39.png)

以下视频显示如何将接头，麦克风和扬声器焊接到AMP皮肤上。

有关皮肤组件的电路原理图和数据表，请参阅EasyPy硬件。

###4.1. 示例代码
AMP皮肤有一个扬声器，`DAC(1)`通过一个小功率放大器连接。放大器的音量由数字电位器控制，数字电位器是总在线具有地址46的I2C设备`IC2(1)`。

要设置音量，请定义以下功能：

    import pyb
    def volume(val):
        pyb.I2C(1, pyb.I2C.MASTER).mem_write(val, 46, 0)

然后你可以这样做：

    >>> volume(0)   # minimum volume	; 最小音量
    >>> volume(127) # maximum volume	; 最大音量

要播放声音，请使用对象的`write_timed`方法`DAC`。例如：

    import math
    from pyb import DAC
    
    # create a buffer containing a sine-wave
    buf = bytearray(100)
    for i in range(len(buf)):
        buf[i] = 128 + int(127 * math.sin(2 * math.pi * i / len(buf)))
    
    # output the sine-wave at 400Hz
    dac = DAC(1)
    dac.write_timed(buf, 400 * len(buf), mode=DAC.CIRCULAR)

您还可以使用Python `wave`模块播放WAV文件。你可以在[这里](http://baidu.com)获得wave模块，你也需要这里提供的块模块。将它们放在你的EasyPy上（在flash或顶级目录中的SD卡上）。您将需要一个8位WAV文件来播放，例如这个，或者使用该命令转换您拥有的任何文件：

    avconv -i original.wav -ar 22050 -codec pcm_u8 test.wav

然后你可以这样做：

    >>> import wave
    >>> from pyb import DAC
    >>> dac = DAC(1)
    >>> f = wave.open('test.wav')
    >>> dac.write_timed(f.readframes(f.getnframes()), f.getframerate())

这应该播放WAV文件。请注意，这会将整个文件读入RAM，因此必须足够小以适应它。

要播放更大的波形文件，您必须使用micro-SD卡存储它。此外，必须以小块的形式读取文件并将其发送到DAC，以适应微控制器的RAM限制。这是一个示例函数，可以播放高达16kHz采样的8位波形文件：

    import wave
    from pyb import DAC
    from pyb import delay
    dac = DAC(1)
    
    def play(filename):
        f = wave.open(filename, 'r')
        total_frames = f.getnframes()
        framerate = f.getframerate()
    
        for position in range(0, total_frames, framerate):
            f.setpos(position)
            dac.write_timed(f.readframes(framerate), framerate)
            delay(1000)

该函数读取一秒钟的数据并将其发送到DAC。然后它等待一秒钟并将文件光标移动到新位置以在for循环的下一次迭代中读取下一秒数据。它每秒播放一秒钟的音频。


##5. LCD顯示
本教程介绍如何开始使用LCD160CR皮肤。

![](https://raw.githubusercontent.com/Honor-D/EasyPython/master/img/wps40.png)

有关显示器驱动程序的详细文文件，请参阅 lcd160cr模块。

###5.1. 插入显示
显示器可以直接插入EasyPy（支持所有EasyPy版本）。将显示器插入EasyPy的顶部，位于X或Y位置。显示屏应覆盖EasyPy的一半。请参见上图，了解如何实现这一目标; 图片的左半部分显示X位置，右半部分显示Y位置。

###5.2.获取驱动程序
您可以使用电源/使能引脚和I2C总线直接控制显示，但使用lcd160cr模块提供的驱动程序要方便得多 。此驱动程序包含在最新版本的EasyPy固件中（请参阅[此处](http://baidu.com)）。您也可以在[这里](http://baidu.com)找到GitHub存储库中的驱动程序 ，要使用此版本，您需要将文件复制到您的板上，然后复制到通过import搜索的目录（通常是lib /目录）。

安装驱动程序后，需要导入它才能使用它：

    import lcd160cr

###5.3. 测试显示
有一个测试程序可用于测试显示器的功能，也可以作为开始创建使用LCD的代码的基础。该测试程序包含在最新版本的EasyPy固件中，也可以在GitHub上 [找到](http://baidu.com)。

要从MicroPython提示符运行测试，请执行以下操作：

    >>> import lcd160cr_test

然后它会打印一些简短的说明。您将需要知道显示器连接到哪个位置（X或Y），然后您可以运行（假设您在X位置显示）：

    >>> test_all('X')

###5.4. 绘制一些图形
您必须先创建一个LCD160CR对象来控制显示。这样做使用：

    >>> import lcd160cr
    >>> lcd = lcd160cr.LCD160CR('X')

这假定您的显示器连接在X位置。如果它在Y位置，则使用。`lcd = lcd160cr.LCD160CR('Y')`

要擦除屏幕并画一条线，请尝试：

    >>> lcd.set_pen(lcd.rgb(255, 0, 0), lcd.rgb(64, 64, 128))
    >>> lcd.erase()
    >>> lcd.line(10, 10, 50, 80)

下一个示例在屏幕上绘制随机矩形。您可以通过先在提示符下按“Ctrl-E”，然后在粘贴文本后按“Ctrl-D”将其复制并粘贴到MicroPython提示符中。

    from random import randint
    for i in range(1000):
        fg = lcd.rgb(randint(128, 255), randint(128, 255), randint(128, 255))
        bg = lcd.rgb(randint(0, 128), randint(0, 128), randint(0, 128))
        lcd.set_pen(fg, bg)
        lcd.rect(randint(0, lcd.w), randint(0, lcd.h), randint(10, 40), randint(10, 40))

###5.5. 使用触摸传感器
显示器包括电阻式触摸传感器，其可以报告屏幕上单个基于力的触摸的位置（以像素为单位）。要查看屏幕上是否有触摸，请使用：

    >>> lcd.is_touched()

这将返回`False`或`True`。触摸屏幕时运行上述命令以查看结果。

要获得触摸的位置，您可以使用以下方法：

    >>> lcd.get_touch()

这将返回一个3元组，第一个条目为0或1，具体取决于当前是否有任何触摸屏幕的内容（如果有，则为1），元组中的第二个和第三个条目为x和y坐标。当前（或最近）的触摸。

###5.6. 将EasyPython输出定向到显示
该显示器支持来自UART的输入并实现基本的VT100命令，这意味着它可以用作简单的通用终端。让我们设置EasyPy将其输出复位向到显示器。

首先，您需要创建一个UART对象：

    >>> import pyb
    >>> uart = pyb.UART('XA', 115200)

这假设您的显示器已连接到位置X.如果它位于Y位置，则使用。`uart = pyb.UART('YA', 115200)`

现在，将REPL输出连接到此UART：

    >>> pyb.repl_uart(uart)

从现在开始，您在EasyPython提示符下键入的任何内容以及您收到的任何输出都将显示在显示屏上。

此模式无需设置命令，您可以使用显示屏监控任何UART的输出，而不仅仅是来自EasyPy。所需要的只是显示器具有电源，接地和电源/使能引脚驱动为高电平。然后，显示器的UART输入上的任何字符都将打印到屏幕上。您可以使用该set_uart_baudrate方法从默认值115200调整UART波特率 。